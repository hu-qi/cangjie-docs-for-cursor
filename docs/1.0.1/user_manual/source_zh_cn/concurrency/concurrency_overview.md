  
# 并发概述

并发编程是现代编程语言中不可或缺的特性，仓颉编程语言提供 _抢占式的线程模型_ 作为并发编程机制。线程可以细分为两种不同概念， **语言线程** 和 **native 线程** 。

  * 语言线程是编程语言中并发模型的基本执行单位。仓颉编程语言希望给开发者提供一个友好、高效、统一的并发编程界面，让开发者无需关心操作系统线程、用户态线程等差异，因此提供 **仓颉线程** 的概念。开发者在大多数情况下只需面向仓颉线程编写并发代码。
  * native 线程指语言实现中所使用到的线程（一般是操作系统线程），它们作为语言线程的具体实现载体。不同编程语言会以不同的方式实现语言线程。例如，一些编程语言直接通过操作系统调用来创建线程，这意味着每个语言线程对应一个 native 线程，这种实现方案一般被称之为 `1:1` 线程模型。此外，另有一些编程语言提供特殊的线程实现，它们允许多个语言线程在多个 native 线程上切换执行，这种也被称为 `M:N` 线程模型，即 M 个语言线程在 N 个 native 线程上调度执行，其中 M 和 N 不一定相等。当前，仓颉语言的实现同样采用 `M:N` 线程模型；因此，仓颉线程本质上是一种用户态的轻量级线程，支持抢占且相比操作系统线程更轻量化。

仓颉线程本质上是用户态的轻量级线程，每个仓颉线程都受到底层 native 线程的调度执行，并且多个仓颉线程可以由一个 native 线程执行。每个 native 线程会不断地选择一个就绪的仓颉线程完成执行，如果仓颉线程在执行过程中发生阻塞（例如等待互斥锁的释放），那么 native 线程会将当前的仓颉线程挂起，并继续选择下一个就绪的仓颉线程。发生阻塞的仓颉线程在重新就绪后会继续被 native 线程调度执行。

在大多数情况下，开发者只需要面向仓颉线程进行并发编程而不需要考虑这些细节。但在进行跨语言编程时，开发者需要谨慎调用可能发生阻塞的 foreign 函数，例如 IO 相关的操作系统调用等。例如，下列示例代码中的新线程会调用 foreign 函数 `socket_read`。在程序运行过程中，某一 native 线程将调度并执行该仓颉线程，在进入到 foreign 函数中后，系统调用会直接阻塞当前 native 线程直到函数执行完成。native 线程在阻塞期间将无法调度其他仓颉线程来执行，这会降低程序执行的吞吐量。
    
    __
    
    foreign socket_read(sock: Int64): CPointer\<Int8\>
    
    let fut = spawn {
        let sock: Int64 = ...
        let ptr = socket_read(sock)
    }
    
> **注意：**
> 
> 本文档在没有歧义的情况下将直接以 **线程** 简化对 **仓颉线程** 的指代。